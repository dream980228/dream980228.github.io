(window.webpackJsonp=window.webpackJsonp||[]).push([[154],{610:function(s,t,e){"use strict";e.r(t);var n=e(2),o=Object(n.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("p",[s._v("要疯掉了，一个简单的登录流程，不知道怎么实现。前两天突然想到，用户是如何登录的，在我以前的印象中就是有个登录窗口，以提交表单形式查询对应的数据库表，看看有没有这个用户的信息，如果用户名和密码是正确的，那么就可以放行。")]),s._v(" "),e("p",[s._v("但是登录不是这样的啊，这样登录只不过是查询了一次数据库表，发送了一次http请求，而http请求是无状态的，也就是说并没有保存这个登录的状态。像正常登录网站，登录成功之后对应有用户的一些信息，可以实现退出注册，这才是个登录啊。")]),s._v(" "),e("p",[s._v("在前后端还未分离的时候，Tomcat会生成一个session，也就是一次会话，在这个会话之中可以保存用户的一些信息，在前后端未分离时，前端页面能获取到这个session，后端也能获取到这个session，可以当用户登录成功之后，后端将用户的关键信息加入到session中，然后前端就可以验证在此session中是否有此用户关键信息，以此判断是否已经登录成功。")]),s._v(" "),e("p",[s._v("但是前后端分离之后，前端和后端并不是部署到一起，彼此是独立项目，却又相关联。此时session前端并不能直接访问到了，所以得需要新的解决方案。具体也可以这样，后端登录验证通过之后，向前端发送一些它能识别的信息，可以理解为一个锁，前端拿到这个锁保存下来，检测到这个锁的存在，说明用户已经登录成功，每次请求时，都需要带上这个锁，后端才能识别你是谁，是否有权限，已经登录。")]),s._v(" "),e("p",[s._v("这个锁可以是token或者是别的，自己定义的应该也可以，不过没那么安全和成熟吧。token的使用也就是如此，后端生成，前端保存，以此作为身份认证。大概就是这样吧。现在大致知道需要使用jwt和spring sercurity，但是还不知如何使用，用不好。")]),s._v(" "),e("p",[s._v("至今也没有实现，可难受了，有时候也真想着去放弃，但是咬咬牙，还是不愿意认命。")])])}),[],!1,null,null,null);t.default=o.exports}}]);